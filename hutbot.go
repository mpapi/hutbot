package main

// At a high level, the bot has two concepts: messagers, which produce messages
// and optionally consume responses, and responders, which consume messages and
// optionally produce responses -- consider an IRC messager, that sends a
// message whenever someone speaks in a channel and speaks itself whenever it
// receives a response, and a shell script responder, that runs a shell script
// on each message and sends its output back as a response.
//
// Each messager and responder run in goroutines and communicate on channels;
// every message is dispatched to all responder goroutines and every response
// is dispatched to all messager. So, for example, someone addresses the bot in
// IRC, the IRC messager sends a message that causes a script responder to run
// a script and respond with its output, and the IRC messager then "replies"
// with the script's output in IRC.

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"github.com/thoj/go-ircevent"
	"io"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"regexp"
	"strings"
	"time"
)

// Command line options.
var botName = flag.String("name", "hutbot", "the bot's nick")
var botPassword = flag.String("password", "", "the bot's password")
var botTLS = flag.Bool("tls", true, "whether to use TLS")

// Messages are created by events (e.g. someone speaking in IRC) and dispatched
// to responders.
type Message struct {
	Messager Messager
	Sender   string
	Channel  string
	Contents string
	Created  time.Time
}

func (message Message) Empty() bool {
	return len(strings.TrimSpace(message.Contents)) <= 0
}

// Responses can be generated by responders (e.g. by running a shell script)
// when they receive messages.
type Response struct {
	Responder Responder
	Message   *Message
	Contents  string
	Target    string // nickname for target, if empty, defaults to channel
	Created   time.Time
}

func (response Response) Empty() bool {
	return len(strings.TrimSpace(response.Contents)) <= 0
}

// Messagers produce messages and consume responses.
type Messager interface {
	Process(chan<- Message, <-chan Response)
}

// StreamMessager produces messages from lines of text on an input stream.
type StreamMessager struct {
	Reader io.Reader
}

func (s *StreamMessager) Process(messages chan<- Message, responses <-chan Response) {
	lines := make(chan string)
	go func() {
		scanner := bufio.NewScanner(s.Reader)
		for scanner.Scan() {
			lines <- scanner.Text()
		}
	}()

	for {
		select {
		case line := <-lines:
			messages <- Message{s, "stdin", "stdin", line, time.Now()}
		case r := <-responses:
			log.Println("[stream]", r)
		}
	}
}

// IRCMessager produces messages from IRC chats.
type IRCMessager struct {
	Server       string
	UseTLS       bool
	Channel      string
	Nick         string
	IdentifyPass string
}

func (i *IRCMessager) callback(cb func(*irc.Event)) func(*irc.Event) {
	return func(event *irc.Event) {
		log.Println("[irc]", event.Code, event, event.Message, event.Arguments, event.Nick)
		if len(event.Arguments) == 0 || event.Arguments[0] == i.Channel {
			cb(event)
		}
	}
}

func (i *IRCMessager) Process(messages chan<- Message, responses <-chan Response) {
	log.Println("[irc] setting up")
	conn := irc.IRC(i.Nick, i.Nick)

	conn.AddCallback("PRIVMSG", i.callback(func(event *irc.Event) {
		messages <- Message{i, event.Nick, event.Arguments[0], event.Message, time.Now()}
	}))
	conn.AddCallback("JOIN", i.callback(func(event *irc.Event) {
		contents := fmt.Sprintf("%s: irc-join", i.Nick)
		messages <- Message{i, event.Nick, event.Arguments[0], contents, time.Now()}
	}))
	conn.AddCallback("PART", i.callback(func(event *irc.Event) {
		contents := fmt.Sprintf("%s: irc-part", i.Nick)
		messages <- Message{i, event.Nick, event.Arguments[0], contents, time.Now()}
	}))
	conn.AddCallback("QUIT", i.callback(func(event *irc.Event) {
		contents := fmt.Sprintf("%s: irc-quit %s", i.Nick, event.Message)
		messages <- Message{i, event.Nick, i.Channel, contents, time.Now()}
	}))

	log.Println("[irc ] connecting to", i.Server, i.Channel)
	conn.UseTLS = i.UseTLS
	conn.Connect(i.Server)

	if len(i.IdentifyPass) > 0 {
		conn.Privmsg("nickserv", fmt.Sprintf("identify %s %s", i.Nick, i.IdentifyPass))
	}

	log.Println("[irc ] joining")
	conn.Join(i.Channel)

	for response := range responses {
		if response.Empty() {
			continue
		}

		target := response.Target
		if target == "" {
			target = i.Channel
		}
		for _, line := range strings.Split(response.Contents, "\n") {
			conn.Privmsg(target, line)
			time.Sleep(25 * time.Millisecond)
		}
	}
}

// Invokes a .log script for each non-empty response it gets, and ignores the
// results of the script.
type ResponseLogger struct{}

func (r *ResponseLogger) Process(messages chan<- Message, responses <-chan Response) {
	wd, _ := os.Getwd()
	for response := range responses {
		// Skip empty responses.
		if response.Empty() {
			continue
		}

		// Run .log scripts for each line in the response.
		for _, line := range strings.Split(response.Contents, "\n") {
			env := []string{
				"HUTBOT_EVENT=log_response",
				fmt.Sprintf("HUTBOT_TARGET=%s", response.Target),
				fmt.Sprintf("HUTBOT_CREATED=%d", response.Created.Unix()),
				fmt.Sprintf("HUTBOT_BOT=%s", *botName),
				fmt.Sprintf("HUTBOT_DIR=%s", wd),
				fmt.Sprintf("HUTBOT_RESPONSE=%s", line),
			}
			if response.Message != nil {
				env = append(env,
					fmt.Sprintf("HUTBOT_SENDER=%s", response.Message.Sender),
					fmt.Sprintf("HUTBOT_CHANNEL=%s", response.Message.Channel),
					fmt.Sprintf("HUTBOT_MESSAGE=%s", response.Message.Contents))
			}
			for _, path := range paths(".log") {
				execute(path, "", env)
			}
		}
	}
}

// Invokes a .log script for each non-empty message it gets, and ignores the
// results of the script.
type MessageLogger struct{}

func (m *MessageLogger) Process(messages <-chan Message, responses chan<- Response) {
	wd, _ := os.Getwd()
	for message := range messages {
		if message.Empty() {
			continue
		}
		env := []string{
			"HUTBOT_EVENT=log_message",
			fmt.Sprintf("HUTBOT_SENDER=%s", message.Sender),
			fmt.Sprintf("HUTBOT_CHANNEL=%s", message.Channel),
			fmt.Sprintf("HUTBOT_CREATED=%d", message.Created.Unix()),
			fmt.Sprintf("HUTBOT_BOT=%s", *botName),
			fmt.Sprintf("HUTBOT_DIR=%s", wd),
			fmt.Sprintf("HUTBOT_MESSAGE=%s", message.Contents),
		}
		for _, path := range paths(".log") {
			execute(path, "", env)
		}
	}
}

// Responders consume messages and produce responses.
type Responder interface {
	Process(<-chan Message, chan<- Response)
}

// PeriodicScript produces unsolicited responses by periodically running
// scripts.
type PeriodicScript struct{}

func (p *PeriodicScript) Process(messages <-chan Message, responses chan<- Response) {
	ticks1Min := time.Tick(time.Minute)
	ticks1Hour := time.Tick(time.Hour)
	ticks1Day := time.Tick(24 * time.Hour)

	wd, _ := os.Getwd()
	env := []string{
		fmt.Sprintf("HUTBOT_BOT=%s", *botName),
		fmt.Sprintf("HUTBOT_DIR=%s", wd),
	}

	runScripts := func(dir string) {
		for _, path := range paths(dir) {
			if out, err := execute(path, "", env); err == nil {
				contents := strings.TrimRight(string(out), " \t\r\n")
				responses <- Response{p, nil, contents, "", time.Now()}
			} else {
				contents := fmt.Sprintf("error: %s %s", path, err)
				responses <- Response{p, nil, contents, "", time.Now()}
			}
		}
	}

	for {
		select {
		case <-messages:
			// Ignore.
		case <-ticks1Min:
			runScripts(".minute")
		case <-ticks1Hour:
			runScripts(".hour")
		case <-ticks1Day:
			runScripts(".day")
		}
	}
}

// CommandScript produces responses whenever messages are addressed to the bot,
// by running scripts whose paths are determined by the content of the message.
type CommandScript struct{}

// Return a slice of the paths of scripts to run based on `name`.
//
// * If `name` is an executable script, include it.
// * If `name` is a directory, include any executable scripts from its
//   immediate children.
func paths(name string) []string {
	// If there's no name, we're done.
	if len(strings.TrimSpace(name)) == 0 {
		return []string{}
	}

	path := "./" + name
	info, err := os.Stat(path)

	// If the path doesn't exist, punt. Otherwise, if it's a directory, inspect
	// its contents. Otherwise, if it's executable, return it.
	if err != nil {
		return []string{}
	} else if info.IsDir() {
		entries, err := ioutil.ReadDir(path)

		// If we can't read the dir, abort.
		if err != nil {
			return []string{}
		}

		// Otherwise, look for executables in the dir.
		result := make([]string, 0)
		for _, entry := range entries {
			if !entry.IsDir() && isExec(entry) {
				result = append(result, path+"/"+entry.Name())
			}
		}
		return result
	} else if isExec(info) {
		return []string{path}
	}
	return []string{}
}

// Is the given file executable by *someone*?
func isExec(f os.FileInfo) bool {
	return (f.Mode()&0111 != 0)
}

// Run the script at `path`, passing it `stdin` and using environment vars
// `env`. Returns stdout and any error that occurred.
func execute(path string, stdin string, env []string) ([]byte, error) {
	cmd := exec.Command(path)
	cmd.Env = env
	cmd.Stdin = bytes.NewReader([]byte(stdin))
	return cmd.Output()
}

type PathAndTarget struct {
	Path   string
	Target string
}

func (c *CommandScript) Process(messages <-chan Message, responses chan<- Response) {
	pattern := regexp.MustCompile(
		fmt.Sprintf(`%s:\s*([^. \t\r\n]\S*)(\s(.+))?`, *botName))

	for message := range messages {
		var command, args string
		commandFound := false

		match := pattern.FindStringSubmatch(message.Contents)
		if match != nil && len(match) == 4 {
			commandFound = true
			command = match[1]
			args = match[3]
		}
		wd, _ := os.Getwd()
		env := []string{
			fmt.Sprintf("HUTBOT_SENDER=%s", message.Sender),
			fmt.Sprintf("HUTBOT_CHANNEL=%s", message.Channel),
			fmt.Sprintf("HUTBOT_CREATED=%d", message.Created.Unix()),
			fmt.Sprintf("HUTBOT_BOT=%s", *botName),
			fmt.Sprintf("HUTBOT_DIR=%s", wd),
			fmt.Sprintf("HUTBOT_COMMAND=%s", command),
			fmt.Sprintf("HUTBOT_ARGS=%s", args),
			fmt.Sprintf("HUTBOT_MESSAGE=%s", message.Contents),
		}

		var pts []PathAndTarget
		if commandFound {
			pts = appendPaths(pts, paths(command), "")
			pts = appendPaths(pts, paths("private/"+command), message.Sender)
			if len(pts) == 0 {
				pts = appendPaths(pts, paths(".missing"), "")
			}
		}
		pts = appendPaths(pts, paths(".all"), "")

		for _, pt := range pts {
			if out, err := execute(pt.Path, args, env); err == nil {
				contents := strings.TrimRight(string(out), " \t\r\n")
				responses <- Response{c, &message, contents, pt.Target, time.Now()}
			} else {
				contents := fmt.Sprintf("error: %s %s", pt.Path, err)
				responses <- Response{c, &message, contents, "", time.Now()}
			}
		}
	}
}

func appendPaths(pts []PathAndTarget, paths []string, target string) []PathAndTarget {
	result := pts[:]
	for _, path := range paths {
		result = append(result, PathAndTarget{path, target})
	}
	return result
}

// StartMessager runs the messager in a goroutine and allocates a response
// channel for dispatching reponses to it.
func StartMessager(m Messager, messageChan chan<- Message) chan<- Response {
	responseChan := make(chan Response)
	go m.Process(messageChan, responseChan)
	return responseChan
}

// StartResponder runs the responder in a goroutine and allocates a message
// channel for dispatching messages to it.
func StartResponder(r Responder, responseChan chan<- Response) chan<- Message {
	messageChan := make(chan Message)
	go r.Process(messageChan, responseChan)
	return messageChan
}

func main() {
	log.SetFlags(log.LstdFlags | log.Lmicroseconds)
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s [options] server:port channel\n", os.Args[0])
		flag.PrintDefaults()
	}
	flag.Parse()
	if len(flag.Args()) != 2 {
		flag.Usage()
		return
	}

	botServer := flag.Arg(0)
	botChannel := flag.Arg(1)

	// Set up messagers.
	messages := make(chan Message, 4096)
	messagers := []Messager{
		&IRCMessager{
			Server:       botServer,
			UseTLS:       *botTLS,
			Nick:         *botName,
			Channel:      botChannel,
			IdentifyPass: *botPassword,
		},
		&StreamMessager{Reader: os.Stdin},
		&ResponseLogger{},
	}
	responseChans := []chan<- Response{}
	for _, messager := range messagers {
		responseChans = append(responseChans, StartMessager(messager, messages))
	}

	// Set up responders.
	responses := make(chan Response, 64)
	responders := []Responder{
		&PeriodicScript{},
		&CommandScript{},
		&MessageLogger{},
	}
	messageChans := []chan<- Message{}
	for _, responder := range responders {
		messageChans = append(messageChans, StartResponder(responder, responses))
	}

	// Dispatch responses back to all messagers.
	go func() {
		for response := range responses {
			log.Println("[response]", response)
			for _, messager := range responseChans {
				messager <- response
			}
		}
	}()

	// Dispatch messages to all responders.
	for message := range messages {
		if message.Contents == "__hutbot: quit" {
			break
		}
		log.Println("[message]", message)
		for _, responder := range messageChans {
			responder <- message
		}
	}
}
